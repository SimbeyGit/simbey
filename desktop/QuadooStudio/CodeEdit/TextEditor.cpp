//
//	MODULE:		TextEditor.cpp
//
//	NOTES:		This is an adaptation of the text editing from NeatPad (https://www.catch22.net/tags/neatpad/).
//

#include <windows.h>
#include <afxres.h>	// If you don't have MFC installed, there is a copy of this file in the "shared" folder
#include "RichEdit.h"
#include "Library\Core\CoreDefs.h"
#include "Library\Window\DialogHost.h"
#include "Library\Util\Formatting.h"
#include "OptionsDlg.h"
#include "TextDocument.h"
#include "TextEditor.h"

/* Generated by HexEdit */
static BYTE XORMask[128] =
{
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xff, 0xff, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xc3, 0xff, 
  0xff, 0xff, 0x83, 0xff, 0xff, 0xff, 0x03, 0xff, 0xff, 0xfe, 0x03, 0xff, 0xff, 0xfc, 0x03, 0xff, 
  0xff, 0xf8, 0x03, 0xff, 0xff, 0xf0, 0x03, 0xff, 0xff, 0xe0, 0x03, 0xff, 0xff, 0xc0, 0x03, 0xff, 
  0xff, 0xfc, 0x03, 0xff, 0xff, 0xfc, 0x03, 0xff, 0xff, 0xf8, 0x63, 0xff, 0xff, 0xf8, 0x73, 0xff, 
  0xff, 0xf0, 0xfb, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 
  0xff, 0xf3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

/* Generated by HexEdit */
static BYTE ANDMask[128] =
{
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x18, 0x00, 
  0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x01, 0xf8, 0x00, 
  0x00, 0x03, 0xf8, 0x00, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x01, 0xf8, 0x00, 
  0x00, 0x01, 0xb8, 0x00, 0x00, 0x01, 0x98, 0x00, 0x00, 0x03, 0x08, 0x00, 0x00, 0x03, 0x00, 0x00, 
  0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

void PaintRect (HDC hdc, const RECT& rect, COLORREF fill)
{
	fill = SetBkColor(hdc, fill);
	ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rect, 0, 0, 0);
	SetBkColor(hdc, fill);
}

void PaintRect (HDC hdc, int x, int y, int width, int height, COLORREF fill)
{
	RECT rect = { x, y, x+width, y+height };
	PaintRect(hdc, rect, fill);
}

COLORREF MixRGB (COLORREF rgbCol1, COLORREF rgbCol2)
{
	return RGB(
		(GetRValue(rgbCol1) + GetRValue(rgbCol2)) / 2,
		(GetGValue(rgbCol1) + GetGValue(rgbCol2)) / 2,
		(GetBValue(rgbCol1) + GetBValue(rgbCol2)) / 2
		);
}

COLORREF RealizeColor (COLORREF col)
{
	COLORREF result = col;

	if(col & 0x80000000)
		result = GetSysColor(col & 0xff);

	if(col & 0x40000000)
		result = MixRGB(GetSysColor((col & 0xff00) >> 8), result);

	if(col & 0x20000000)
		result = MixRGB(GetSysColor((col & 0xff00) >> 8), result);

	return result;
}

int CRLF_size (PCWSTR szText, int nLength)
{
	if(nLength >= 2)
	{
		if(szText[nLength-2] == '\r' && szText[nLength-1] == '\n')
			return 2;
	}

	if(nLength >= 1)
	{
		if(szText[nLength-1] == '\r' || szText[nLength-1] == '\n' || 
			szText[nLength-1] == '\x0b' || szText[nLength-1] == '\x0c' ||
			szText[nLength-1] == '\x85' || szText[nLength-1] == 0x2028 || 
			szText[nLength-1] == 0x2029)
			return 1;
	}	

	return 0;
}

//
//	Strip CR/LF combinations from the end of a line and
//  replace with a single space character (for drawing purposes)
//
int StripCRLF (PWSTR szText, ATTR *attr, int nLength, bool fAllow)
{
	if(nLength >= 2)
	{
		if(szText[nLength-2] == '\r' && szText[nLength-1] == '\n')
		{
			attr[nLength-2].eol = TRUE;

			// convert CRLF to a single space
			szText[nLength-2] = ' ';
			return nLength - 1 - (int)fAllow;
		}
	}

	if(nLength >= 1)
	{
		if( szText[nLength-1] == '\x0b' ||
			szText[nLength-1] == '\x0c' ||
			szText[nLength-1] == 0x0085 || 
			szText[nLength-1] == 0x2029 || 
			szText[nLength-1] == 0x2028)
		{
			attr[nLength-1].eol = TRUE;
			//szText[nLength-1] = ' ';
			return nLength - 0;//(int)fAllow;
		}

		if(szText[nLength-1] == '\r')
		{
			attr[nLength-1].eol = TRUE;
		}

		if(szText[nLength-1] == '\n')
		{
			attr[nLength-1].eol = TRUE;
		}
	}

	return nLength;
}

int ScrollDir (int counter, int distance)
{
	if(distance > 48)		return 5;
	if(distance > 16)		return 2;
	if(distance > 3)		return 1;
	if(distance > 0)		return counter % 5 == 0 ? 1 : 0;

	if(distance < -48)		return -5;
	if(distance < -16)		return -2;
	if(distance < -3)		return -1;
	if(distance < 0)		return counter % 5 == 0 ? -1 : 0;

	return 0;
}

CTextEditor::CTextEditor (HINSTANCE hInstance, bool fDarkMode, bool fUseSystemColors) :
	m_hInstance(hInstance),
	m_pTextDoc(NULL),
	m_hMarginCursor(NULL)
{
	// Font-related data
	m_nNumFonts			= 1;
	m_nHeightAbove		= 0;
	m_nHeightBelow		= 0;

	m_nSelectionStart	= 0;
	m_nSelectionEnd		= 0;
	m_nSelectionType	= SEL_NONE;
	m_nCursorOffset		= 0;
	m_nCurrentLine		= 0;

	m_nCaretPosX		= 0;
	m_nAnchorPosX		= 0;

	m_nLineHeight		= 0;
	m_nMaxAscent		= 0;

	for(int i = 0; i < USP_CACHE_SIZE; i++)
	{
		m_uspCache[i].usage   = 0;
		m_uspCache[i].lineno  = 0;
		m_uspCache[i].uspData = UspAllocate();
	}

	SystemParametersInfo(SPI_GETCARETWIDTH, 0, &m_nCaretWidth, 0);

	// Display-related data
	m_uStyleFlags		= 0;
	m_nLongLineLimit	= 256;
	if(m_nCaretWidth == 0)
		m_nCaretWidth = 2;

	SetDarkMode(fDarkMode, fUseSystemColors);

	ZeroMemory(m_uspFontList, sizeof(m_uspFontList));

	// Runtime data
	m_nSelectionMode	= SEL_NONE;
	m_nEditMode			= MODE_INSERT;
	m_nScrollTimer		= 0;
	m_fHideCaret		= false;
}

CTextEditor::~CTextEditor ()
{
	SafeRelease(m_pTextDoc);
	DestroyCursor(m_hMarginCursor);

	for(int i = 0; i < ARRAYSIZE(m_uspCache); i++)
		UspFree(m_uspCache[i].uspData);
}

HRESULT CTextEditor::Register (HINSTANCE hInstance, DWORD dwClassCookie)
{
	HRESULT hr;
	WCHAR wzClass[64];
	WNDCLASSEX wnd = {0};

	Check(BuildClassName(dwClassCookie, wzClass, ARRAYSIZE(wzClass)));

	wnd.cbSize = sizeof(WNDCLASSEX);
	wnd.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
	wnd.cbClsExtra = 0;
	wnd.cbWndExtra = 0;
	wnd.hInstance = hInstance;
	wnd.hIcon = NULL;
	wnd.hCursor = LoadCursor(NULL, IDC_ARROW);
	wnd.hbrBackground = NULL;
	wnd.lpszMenuName = NULL;
	wnd.lpszClassName = wzClass;

	Check(RegisterClass(&wnd, NULL));

Cleanup:
	return hr;
}

HRESULT CTextEditor::Unregister (HINSTANCE hInstance, DWORD dwClassCookie)
{
	HRESULT hr;
	WCHAR wzClass[64];

	Check(BuildClassName(dwClassCookie, wzClass, ARRAYSIZE(wzClass)));
	Check(UnregisterClass(wzClass, hInstance));

Cleanup:
	return hr;
}

HRESULT CTextEditor::Initialize (HWND hwndParent, const RECT& rcSite, INT nTabWidth, DWORD dwClassCookie)
{
	HRESULT hr;
	WCHAR wzClass[64];

	Check(BuildClassName(dwClassCookie, wzClass, ARRAYSIZE(wzClass)));

	m_hMarginCursor = CreateCursor(GetModuleHandle(NULL), 21, 5, 32, 32, XORMask, ANDMask);
	CheckIfGetLastError(NULL == m_hMarginCursor);

	Check(CTextDocument::Create(nTabWidth, &m_pTextDoc));

	Check(Create(0, WS_VSCROLL | WS_HSCROLL | WS_CHILD | WS_VISIBLE, wzClass, NULL, rcSite.left, rcSite.top, rcSite.right - rcSite.left, rcSite.bottom - rcSite.top, hwndParent, SW_NORMAL));

	{
		TVNCURSORINFO ci;
		ci.nLineNo = m_nCurrentLine;
		ci.nColumnNo = GetCurrentColumn();
		ci.nOffset = m_nCursorOffset;
		NotifyParent(TVN_CURSOR_CHANGE, &ci);
	}

Cleanup:
	return hr;
}

HRESULT CTextEditor::Prepare (__in_ecount_opt(cchText) PCWSTR pcwzText, INT cchText)
{
	HRESULT hr;
	TStackRef<ITextDocument> srDocument(m_pTextDoc);

	if(srDocument->IsPrepared())
	{
		srDocument.Release();
		Check(CTextDocument::Create(m_pTextDoc->GetTabWidth(), &srDocument));
	}

	Check(srDocument->Load(pcwzText, cchText));
	SetTextDocument(srDocument);

	ResetLineCache();
	UpdateView(false);
	RefreshWindow();

Cleanup:
	return hr;
}

// CBaseWindow

HINSTANCE CTextEditor::GetInstance (VOID)
{
	return m_hInstance;
}

VOID CTextEditor::OnFinalDestroy (HWND hwnd)
{
}

HRESULT CTextEditor::FinalizeAndShow (DWORD dwStyle, INT nCmdShow)
{
	return __super::FinalizeAndShow(dwStyle, nCmdShow);
}

BOOL CTextEditor::DefWindowProc (UINT message, WPARAM wParam, LPARAM lParam, LRESULT& lResult)
{
	switch(message)
	{
	case WM_CREATE:
		// Set the default font
		OnSetFont((HFONT)GetStockObject(ANSI_FIXED_FONT));
		break;

	case WM_ERASEBKGND:
		// Draw contents of TextView whenever window needs updating
		lResult = 1;
		return TRUE;

	case WM_PAINT:
		lResult = OnPaint();
		return TRUE;

	case WM_GETFONT:
		lResult = (LRESULT)m_uspFontList[0].hFont;
		return TRUE;

	case WM_SETFONT:
		lResult = OnSetFont((HFONT)wParam);
		return TRUE;

	case WM_SIZE:
		lResult = OnSize(wParam, LOWORD(lParam), HIWORD(lParam));
		return TRUE;

	case WM_VSCROLL:
		lResult = OnVScroll(LOWORD(wParam), HIWORD(wParam));
		return TRUE;

	case WM_HSCROLL:
		lResult = OnHScroll(LOWORD(wParam), HIWORD(wParam));
		return TRUE;

	case WM_MOUSEACTIVATE:
		lResult = OnMouseActivate((HWND)wParam, LOWORD(lParam), HIWORD(lParam));
		return TRUE;

	case WM_MOUSEWHEEL:
		lResult = OnMouseWheel((short)HIWORD(wParam));
		return TRUE;

	case WM_SETFOCUS:
		lResult = OnSetFocus((HWND)wParam);
		return TRUE;

	case WM_KILLFOCUS:
		lResult = OnKillFocus((HWND)wParam);
		return TRUE;

	case WM_GETDLGCODE:
		// make sure we get arrow-keys, enter, tab, etc when hosted inside a dialog
		return DLGC_WANTALLKEYS;

	case WM_LBUTTONDOWN:
		lResult = OnLButtonDown(wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
		return TRUE;

	case WM_LBUTTONUP:
		lResult = OnLButtonUp(wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
		return TRUE;

	case WM_LBUTTONDBLCLK:
		lResult = OnLButtonDblClick(wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
		return TRUE;

	case WM_MOUSEMOVE:
		lResult = OnMouseMove(wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
		return TRUE;

	case WM_KEYDOWN:
		lResult = OnKeyDown(wParam, lParam);
		return TRUE;

	case WM_UNDO:
	case EM_UNDO:
		lResult = Undo();
		return TRUE;

	case EM_REDO:
		lResult = Redo();
		return TRUE;

	case EM_CANUNDO:
		lResult = CanUndo();
		return TRUE;

	case EM_CANREDO:
		lResult = CanRedo();
		return TRUE;

	case WM_CHAR:
		lResult = OnChar(wParam, lParam);
		return TRUE;

	case WM_SETCURSOR:
		if(LOWORD(lParam) == HTCLIENT)
		{
			lResult = TRUE;
			return TRUE;
		}
		break;

	case WM_TIMER:
		lResult = OnTimer(wParam);
		return TRUE;

	case WM_COPY:
		lResult = OnCopy();
		return TRUE;

	case WM_CUT:
		lResult = OnCut();
		return TRUE;

	case WM_PASTE:
		lResult = OnPaste();
		return TRUE;

	case WM_CLEAR:
		lResult = OnClear();
		return TRUE;

	case EM_SETMODIFY:
		if(0 == wParam)
		{
			m_pTextDoc->ResetModifiedSnapshot();
			lResult = TRUE;
			return TRUE;
		}
		break;

	case WM_GETTEXTLENGTH:
		lResult = m_pTextDoc->Size();
		return TRUE;

	case WM_GETTEXT:
		lResult = GetText((PWSTR)lParam, 0, wParam);
		return TRUE;

	case WM_SETTEXT:
		if(SUCCEEDED(m_pTextDoc->Load((PCWSTR)lParam, TStrLenChecked((PCWSTR)lParam))))
		{
			ResetLineCache();
			m_pTextDoc->ResetModifiedSnapshot();
			UpdateView(false);
			RefreshWindow();
			lResult = TRUE;
			return TRUE;
		}
		break;

	case WM_CONTEXTMENU:
		lResult = OnContextMenu((HWND)wParam, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
		return TRUE;

	case WM_COMMAND:
		switch(LOWORD(wParam))
		{
		case ID_EDIT_UNDO:
			lResult = Undo();
			break;
		case ID_EDIT_REDO:
			lResult = Redo();
			break;
		case ID_EDIT_CUT:
			lResult = OnCut();
			break;
		case ID_EDIT_COPY:
			lResult = OnCopy();
			break;
		case ID_EDIT_PASTE:
			lResult = OnPaste();
			break;
		case ID_EDIT_CLEAR:
			lResult = OnClear();
			break;
		case ID_EDIT_SELECT_ALL:
			lResult = SelectAll();
			break;
		default:
			lResult = SendMessage(GetParent(m_hwnd), WM_COMMAND, wParam, lParam);
			break;
		}
		return TRUE;

	case WM_ENABLE:
		ResetLineCache();
		break;
	}

	return FALSE;
}

bool CTextEditor::IsModified (VOID)
{
	return m_pTextDoc->IsModified();
}

BOOL CTextEditor::Undo (VOID)
{
	if(m_nEditMode == MODE_READONLY)
		return FALSE;

	if(FAILED(m_pTextDoc->Undo(&m_nSelectionStart, &m_nSelectionEnd)))
		return FALSE;

	m_nCursorOffset = m_nSelectionEnd;

	ResetLineCache();
	SendUpdateCommand();
	UpdateView(m_nSelectionStart != m_nSelectionEnd);
	RefreshWindow();

	return TRUE;
}

BOOL CTextEditor::Redo (VOID)
{
	if(m_nEditMode == MODE_READONLY)
		return FALSE;

	if(FAILED(m_pTextDoc->Redo(&m_nSelectionStart, &m_nSelectionEnd)))
		return FALSE;

	m_nCursorOffset = m_nSelectionEnd;

	ResetLineCache();
	SendUpdateCommand();
	UpdateView(m_nSelectionStart != m_nSelectionEnd);
	RefreshWindow();

	return TRUE;
}

bool CTextEditor::CanUndo (VOID)
{
	return m_pTextDoc->CanUndo();
}

bool CTextEditor::CanRedo (VOID)
{
	return m_pTextDoc->CanRedo();
}

ULONG CTextEditor::SelectionSize (VOID)
{
	ULONG s1 = min(m_nSelectionStart, m_nSelectionEnd); 
	ULONG s2 = max(m_nSelectionStart, m_nSelectionEnd); 
	return s2 - s1;
}

BOOL CTextEditor::SelectAll (VOID)
{
	m_nSelectionStart = 0;
	m_nSelectionEnd   = m_pTextDoc->Size();
	m_nCursorOffset   = m_nSelectionEnd;

	UpdateView(true);
	RefreshWindow();

	return m_nSelectionEnd > m_nSelectionStart;
}

VOID CTextEditor::ScrollView (INT xCaret, ULONG nLine)
{
	m_nCursorOffset = m_pTextDoc->LineOffset(nLine) + xCaret;
	UpdateView(false);
}

VOID CTextEditor::SetDarkMode (bool fDarkMode, bool fUseSystemColors)
{
	if(fUseSystemColors || !fDarkMode)
	{
		// Default display colors
		m_rgbColorList[TXC_FOREGROUND]		= SYSCOL(COLOR_WINDOWTEXT);
		m_rgbColorList[TXC_BACKGROUND]		= SYSCOL(COLOR_WINDOW);			// RGB(34,54,106)
		m_rgbColorList[TXC_HIGHLIGHTTEXT]	= SYSCOL(COLOR_HIGHLIGHTTEXT);
		m_rgbColorList[TXC_HIGHLIGHT]		= SYSCOL(COLOR_HIGHLIGHT);
		m_rgbColorList[TXC_HIGHLIGHTTEXT2]	= SYSCOL(COLOR_WINDOWTEXT);		//INACTIVECAPTIONTEXT);
		m_rgbColorList[TXC_HIGHLIGHT2]		= SYSCOL(COLOR_3DFACE);			//INACTIVECAPTION);
		m_rgbColorList[TXC_SELMARGIN1]		= SYSCOL(COLOR_3DFACE);
		m_rgbColorList[TXC_SELMARGIN2]		= SYSCOL(COLOR_3DHIGHLIGHT);
		m_rgbColorList[TXC_MARGIN_BORDER]	= SYSCOL(COLOR_3DSHADOW);
		m_rgbColorList[TXC_MARGIN]			= SYSCOL(COLOR_3DFACE);
		m_rgbColorList[TXC_LONGLINETEXT]	= SYSCOL(COLOR_3DSHADOW);
		m_rgbColorList[TXC_LONGLINE]		= SYSCOL(COLOR_3DFACE);
		m_rgbColorList[TXC_CURRENTLINETEXT] = SYSCOL(COLOR_WINDOWTEXT);
		m_rgbColorList[TXC_CURRENTLINE]		= RGB(230,240,255);
		m_rgbColorList[TXC_DISABLED]		= SYSCOL(COLOR_INACTIVECAPTION);
	}
	else
	{
		m_rgbColorList[TXC_FOREGROUND]		= RGB(255, 255, 255);
		m_rgbColorList[TXC_BACKGROUND]		= RGB(40, 40, 40);
		m_rgbColorList[TXC_HIGHLIGHTTEXT]	= RGB(255, 255, 255);
		m_rgbColorList[TXC_HIGHLIGHT]		= RGB(120, 120, 100);
		m_rgbColorList[TXC_HIGHLIGHTTEXT2]	= RGB(200, 200, 200);		//INACTIVECAPTIONTEXT);
		m_rgbColorList[TXC_HIGHLIGHT2]		= RGB(80, 80, 70);			//INACTIVECAPTION);
		m_rgbColorList[TXC_SELMARGIN1]		= SYSCOL(COLOR_3DFACE);
		m_rgbColorList[TXC_SELMARGIN2]		= SYSCOL(COLOR_3DHIGHLIGHT);
		m_rgbColorList[TXC_MARGIN_BORDER]	= RGB(70, 70, 70);
		m_rgbColorList[TXC_MARGIN]			= RGB(120, 120, 120);
		m_rgbColorList[TXC_LONGLINETEXT]	= SYSCOL(COLOR_3DSHADOW);
		m_rgbColorList[TXC_LONGLINE]		= SYSCOL(COLOR_3DFACE);
		m_rgbColorList[TXC_CURRENTLINETEXT] = RGB(255, 255, 240);
		m_rgbColorList[TXC_CURRENTLINE]		= RGB(70, 70, 60);
		m_rgbColorList[TXC_DISABLED]		= RGB(80, 80, 80);
	}

	if(m_hwnd)
	{
		ResetLineCache();
		RefreshWindow();
	}
}

HRESULT CTextEditor::DisplayOptions (__inout_ecount_opt(cCustom) COLORREF* prgCustom, INT cCustom, __out_opt BOOL* pfChanged)
{
	HRESULT hr;
	CDialogHost dlgHost(m_hInstance);
	COptionsDlg dlgOptions(m_rgbColorList);
	HFONT hFont;

	CheckIf(pfChanged && NULL == prgCustom, E_INVALIDARG);
	CheckIfGetLastError(0 == GetObject(m_uspFontList[0].hFont, sizeof(dlgOptions.m_lfEdit), &dlgOptions.m_lfEdit));

	if(prgCustom)
	{
		if(cCustom > ARRAYSIZE(dlgOptions.m_rgbCustColors))
			cCustom = ARRAYSIZE(dlgOptions.m_rgbCustColors);
		CopyMemory(dlgOptions.m_rgbCustColors, prgCustom, cCustom * sizeof(COLORREF));
	}

	Check(dlgHost.Display(m_hwnd, &dlgOptions));
	CheckIfIgnore(dlgHost.GetReturnValue() != IDOK, E_ABORT);

	if(pfChanged)
	{
		*pfChanged = 0 != memcmp(prgCustom, dlgOptions.m_rgbCustColors, cCustom * sizeof(COLORREF));
		if(*pfChanged)
			CopyMemory(prgCustom, dlgOptions.m_rgbCustColors, cCustom * sizeof(COLORREF));
	}

	hFont = CreateFontIndirect(&dlgOptions.m_lfEdit);
	if(hFont)
		SetFont(hFont, 0);

	UpdateView(false);
	RefreshWindow();

Cleanup:
	return hr;
}

BOOL CTextEditor::ForwardDelete (VOID)
{
	ULONG selstart = min(m_nSelectionStart, m_nSelectionEnd);
	ULONG selend   = max(m_nSelectionStart, m_nSelectionEnd);

	if(selstart != selend)
	{
		m_pTextDoc->Erase(selstart, selend-selstart);
		m_nCursorOffset = selstart;

		m_pTextDoc->Break();
	}
	else
	{
		seqchar_t tmp[2];
		//USPCACHE		* uspCache;
		//CSCRIPT_LOGATTR * logAttr;
		//ULONG			  lineOffset;
		//ULONG			  index;

		size_w n;
		m_pTextDoc->Render(m_nCursorOffset, tmp, 2, &n);

		/*GetLogAttr(m_nCurrentLine, &uspCache, &logAttr, &lineOffset);
	
		index = m_nCursorOffset - lineOffset;

		do
		{
			m_pTextDoc->seq.erase(m_nCursorOffset, 1);
			index++;
		}
		while(!logAttr[index].fCharStop);*/

		ULONG oldpos = m_nCursorOffset;
		MoveCharNext();

		m_pTextDoc->Erase(oldpos, m_nCursorOffset - oldpos);
		m_nCursorOffset = oldpos;

		//if(tmp[0] == '\r')
		//	m_pTextDoc->erase_text(m_nCursorOffset, 2);
		//else
		//	m_pTextDoc->erase_text(m_nCursorOffset, 1);
	}

	m_nSelectionStart = m_nCursorOffset;
	m_nSelectionEnd   = m_nCursorOffset;

	ResetLineCache();
	SendUpdateCommand();
	UpdateView(false);
	RefreshWindow();

	return TRUE;
}

BOOL CTextEditor::BackDelete (VOID)
{
	ULONG selstart = min(m_nSelectionStart, m_nSelectionEnd);
	ULONG selend   = max(m_nSelectionStart, m_nSelectionEnd);

	// if there's a selection then delete it
	if(selstart != selend)
	{
		m_pTextDoc->Erase(selstart, selend - selstart);
		m_nCursorOffset = selstart;
		m_pTextDoc->Break();
	}
	// otherwise do a back-delete
	else if(m_nCursorOffset > 0)
	{
		//m_nCursorOffset--;
		ULONG oldpos = m_nCursorOffset;
		MoveCharPrev();
		//m_pTextDoc->erase_text(m_nCursorOffset, 1);
		m_pTextDoc->Erase(m_nCursorOffset, oldpos - m_nCursorOffset);
	}

	m_nSelectionStart = m_nCursorOffset;
	m_nSelectionEnd   = m_nCursorOffset;

	ResetLineCache();
	SendUpdateCommand();
	UpdateView(false);
	RefreshWindow();

	return TRUE;
}

ULONG CTextEditor::EnterText (PCWSTR pcwzText, ULONG nLength)
{
	ULONG selstart = min(m_nSelectionStart, m_nSelectionEnd);
	ULONG selend   = max(m_nSelectionStart, m_nSelectionEnd);

	BOOL  fReplaceSelection = (selstart == selend) ? FALSE : TRUE;
	ULONG erase_len = nLength;

	switch(m_nEditMode)
	{
	case MODE_READONLY:
		return 0;

	case MODE_INSERT:
		// if there is a selection then remove it
		if(fReplaceSelection)
		{
			// group this erase with the insert/replace operation
			m_pTextDoc->Group();
			m_pTextDoc->Erase(selstart, selend - selstart);
			m_nCursorOffset = selstart;
		}

		if(FAILED(m_pTextDoc->Insert(m_nCursorOffset, pcwzText, nLength)))
			return 0;

		if(fReplaceSelection)
			m_pTextDoc->Ungroup();
		break;

	case MODE_OVERWRITE:
		if(fReplaceSelection)
		{
			erase_len = selend - selstart;
			m_nCursorOffset = selstart;
		}
		else
		{
			ULONG lineoff;
			USPCACHE *uspCache = GetUspCache(0, m_nCurrentLine, &lineoff);

			// single-character overwrite - must behave like 'forward delete'
			// and remove a whole character-cluster (i.e. maybe more than 1 char)
			if(nLength == 1)
			{
				ULONG oldpos = m_nCursorOffset;
				MoveCharNext();
				erase_len = m_nCursorOffset - oldpos;
				m_nCursorOffset = oldpos;
			}

			// if we are at the end of a line (just before the CRLF) then we must
			// not erase any text - instead we act like a regular insertion
			if(m_nCursorOffset == lineoff + uspCache->length_CRLF)
				erase_len = 0;
		}

		if(FAILED(m_pTextDoc->Replace(m_nCursorOffset, pcwzText, nLength, erase_len)))
			return 0;
		break;

	default:
		return 0;
	}

	// update cursor+selection positions
	m_nCursorOffset  += nLength;
	m_nSelectionStart = m_nCursorOffset;
	m_nSelectionEnd   = m_nCursorOffset;

	// we altered the document, recalculate line+scrollbar information
	ResetLineCache();
	UpdateView(true);
	RefreshWindow();

	TVNCURSORINFO ci;
	ci.nLineNo = m_nCurrentLine;
	ci.nColumnNo = GetCurrentColumn();
	ci.nOffset = m_nCursorOffset;
	NotifyParent(TVN_CURSOR_CHANGE, &ci);

	return nLength;
}

VOID CTextEditor::EnableEditor (BOOL fEnable)
{
	EnableWindow(m_hwnd, fEnable);
}

VOID CTextEditor::SetFocus (VOID)
{
	::SetFocus(m_hwnd);
}

VOID CTextEditor::SetTextDocument (ITextDocument* pDocument)
{
	if(m_pTextDoc != pDocument)
	{
		ResetLineCache();
		ReplaceInterface(m_pTextDoc, pDocument);
	}
}

VOID CTextEditor::GetTextEditView (TEXT_EDIT_VIEW* ptev)
{
	ptev->nVScrollPos = m_nVScrollPos;
	ptev->nHScrollPos = m_nHScrollPos;

	ptev->nCurrentLine = m_nCurrentLine;
	ptev->nSelectionStart = m_nSelectionStart;
	ptev->nSelectionEnd = m_nSelectionEnd;
	ptev->nCursorOffset = m_nCursorOffset;
	ptev->nSelMarginOffset1 = m_nSelMarginOffset1;
	ptev->nSelMarginOffset2 = m_nSelMarginOffset2;
	ptev->nCaretPosX = m_nCaretPosX;
	ptev->nAnchorPosX = m_nAnchorPosX;
}

VOID CTextEditor::SetTextEditView (const TEXT_EDIT_VIEW* pctev)
{
	m_nVScrollPos = pctev->nVScrollPos;
	m_nHScrollPos = pctev->nHScrollPos;

	m_nCurrentLine = pctev->nCurrentLine;
	m_nSelectionStart = pctev->nSelectionStart;
	m_nSelectionEnd = pctev->nSelectionEnd;
	m_nCursorOffset = pctev->nCursorOffset;
	m_nSelMarginOffset1 = pctev->nSelMarginOffset1;
	m_nSelMarginOffset2 = pctev->nSelMarginOffset2;
	m_nCaretPosX = pctev->nCaretPosX;
	m_nAnchorPosX = pctev->nAnchorPosX;

	UpdateMetrics();

	{
		TVNCURSORINFO ci;
		ci.nLineNo = m_nCurrentLine;
		ci.nColumnNo = GetCurrentColumn();
		ci.nOffset = m_nCursorOffset;
		NotifyParent(TVN_CURSOR_CHANGE, &ci);
	}
}

VOID CTextEditor::ResetTextEditView (VOID)
{
	TEXT_EDIT_VIEW tev;

	ZeroMemory(&tev, sizeof(tev));
	SetTextEditView(&tev);
}

HRESULT CTextEditor::BuildClassName (DWORD dwClassCookie, __out_ecount(cchMaxClass) PWSTR pwzClass, INT cchMaxClass)
{
	return Formatting::TPrintF(pwzClass, cchMaxClass, NULL, L"QuadooTextEdit_%.8X", dwClassCookie);
}

VOID CTextEditor::RefreshWindow (VOID)
{
	InvalidateRect(m_hwnd, NULL, FALSE);
}

VOID CTextEditor::SendUpdateCommand (VOID)
{
	SendMessage(GetParent(m_hwnd), WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(m_hwnd), EN_UPDATE), (LPARAM)m_hwnd);
}

ULONG CTextEditor::NotifyParent (UINT nNotifyCode, NMHDR* optional)
{
	UINT nCtrlId = GetWindowLong(m_hwnd, GWL_ID);
	NMHDR nmhdr, *pnmhdr = &nmhdr;

	if(optional)
		pnmhdr = optional;

	pnmhdr->hwndFrom = m_hwnd;
	pnmhdr->idFrom = nCtrlId;
	pnmhdr->code = nNotifyCode;

	return SendMessage(GetParent(m_hwnd), WM_NOTIFY, (WPARAM)nCtrlId, (LPARAM)pnmhdr);
}

ULONG CTextEditor::GetStyleMask (ULONG uMask)
{
	return m_uStyleFlags & uMask;
}

ULONG CTextEditor::SetStyleMask (ULONG uMask, ULONG uStyles)
{
	ULONG oldstyle = m_uStyleFlags;

	m_uStyleFlags  = (m_uStyleFlags & ~uMask) | uStyles;

	ResetLineCache();

	// update display here
	UpdateMetrics();
	RefreshWindow();

	return oldstyle;
}

bool CTextEditor::CheckStyle (ULONG uMask)
{
	return (m_uStyleFlags & uMask) ? true : false;
}

//
//	Return an RGB value corresponding to the specified HVC_xxx index
//
//	If the RGB value has the top bit set (0x80000000) then it is
//  not a real RGB value - instead the low 29bits specify one
//  of the GetSysColor COLOR_xxx indices. This allows us to use
//	system colors without worrying about color-scheme changes etc.
//
COLORREF CTextEditor::GetColor (UINT idx)
{
	if(idx >= TXC_MAX_COLORS)
		return 0;

	return RealizeColor(m_rgbColorList[idx]);
}

COLORREF CTextEditor::SetColor (UINT idx, COLORREF rgbColor)
{
	COLORREF rgbOld;

	if(idx >= TXC_MAX_COLORS)
		return 0;

	rgbOld				= m_rgbColorList[idx];
	m_rgbColorList[idx] = rgbColor;

	ResetLineCache();

	return rgbOld;
}

COLORREF CTextEditor::LineColor (ULONG nLineNo)
{
	if(IsWindowEnabled(m_hwnd))
	{
		if(m_nCurrentLine == nLineNo && CheckStyle(TXS_HIGHLIGHTCURLINE))
			return GetColor(TXC_CURRENTLINE);
		else
			return GetColor(TXC_BACKGROUND);
	}
	return GetColor(TXC_DISABLED);
}

COLORREF CTextEditor::LongColor (ULONG nLineNo)
{
	if(m_nCurrentLine == nLineNo && CheckStyle(TXS_HIGHLIGHTCURLINE))
		return GetColor(TXC_CURRENTLINE);
	else
		return GetColor(TXC_LONGLINE);
}

//
//	Invalidate every entry in the cache so we can start afresh
//
void CTextEditor::ResetLineCache ()
{
	for(int i = 0; i < ARRAYSIZE(m_uspCache); i++)
		m_uspCache[i].usage	= 0;
}

ULONG CTextEditor::GetText (PWSTR pwzDest, ULONG nStartOffset, ULONG nLength)
{
	ULONG copied = 0;

	// The provided length includes space for the nil terminator.
	if(1 < nLength)
	{
		CTextIterator itor = static_cast<CTextDocument*>(m_pTextDoc)->Iterate(nStartOffset);
		copied = itor.gettext(pwzDest, nLength - 1);

		// null-terminate
		pwzDest[copied] = L'\0';
	}

	return copied;
}

USPDATA* CTextEditor::GetUspData (HDC hdc, ULONG nLineNo, ULONG* nOffset)
{
	USPCACHE* uspCache = GetUspCache(hdc, nLineNo, nOffset);
	return uspCache ? uspCache->uspData : NULL;
}

USPCACHE* CTextEditor::GetUspCache (HDC hdc, ULONG nLineNo, ULONG* nOffset)
{
	WCHAR*	buff;
	ATTR*	attr;
	ULONG	colno = 0;
	ULONG	off_chars = 0;
	size_w	len;
	HDC		hdcTemp;
	
	USPDATA *uspData;
	ULONG    lru_usage = -1;
	int		 lru_index = 0;

	//
	//	Search the cache to see if we've already analyzed the requested line
	//
	for(int i = 0; i < USP_CACHE_SIZE; i++)
	{
		// remember the least-recently used
		if(m_uspCache[i].usage < lru_usage)
		{
			lru_index = i;
			lru_usage = m_uspCache[i].usage;
		}

		// match the line#
		if(m_uspCache[i].usage > 0 && m_uspCache[i].lineno == nLineNo)
		{
			if(nOffset)
				*nOffset = m_uspCache[i].offset;

			m_uspCache[i].usage++;
			return &m_uspCache[i];
		}
	}

	//
	// not found? overwrite the "least-recently-used" entry
	//
	m_uspCache[lru_index].lineno	= nLineNo;
	m_uspCache[lru_index].usage		= 1;
	uspData = m_uspCache[lru_index].uspData;

	if(hdc == 0)	hdcTemp = GetDC(m_hwnd);
	else			hdcTemp = hdc;

	m_stmTextBuff.Reset();
	m_stmAttrBuff.Reset();

	//
	// get the text for the entire line and apply style attributes
	//
	len = m_pTextDoc->LineLength(nLineNo);

	size_w cbAdvance = len;
	if(cbAdvance == 0) cbAdvance = 1;

	if(nLineNo < m_pTextDoc->LineCount() && SUCCEEDED(m_stmTextBuff.TWriteAdvance(&buff, cbAdvance)) && SUCCEEDED(m_stmAttrBuff.TWriteAdvance(&attr, cbAdvance)))
	{
		size_w cchCopied;

		off_chars = m_pTextDoc->LineOffset(nLineNo);
		m_pTextDoc->Render(off_chars, buff, len, &cchCopied);
	}
	else
	{
		len = 0;
		off_chars = 0;
		buff = L"";
		attr = NULL;
	}

	// cache the line's offset and length information
	m_uspCache[lru_index].offset		= off_chars;
	m_uspCache[lru_index].length		= len;
	m_uspCache[lru_index].length_CRLF	= len - CRLF_size(buff, len);

	len = ApplyTextAttributes(nLineNo, off_chars, colno, buff, len, attr);

	//
	// setup the tabs + itemization states
	//
	int				tablist[]		= { m_pTextDoc->GetTabWidth() };
	SCRIPT_TABDEF	tabdef			= { 1, 0, tablist, 0 };
	SCRIPT_CONTROL	scriptControl	= { 0 };
	SCRIPT_STATE	scriptState		= { 0 };

	//SCRIPT_DIGITSUBSTITUTE scriptDigitSub;
	//ScriptRecordDigitSubstitution(LOCALE_USER_DEFAULT, &scriptDigitSub);
	//ScriptApplyDigitSubstitution(&scriptDigitSub, &scriptControl, &scriptState);

	//
	// go!
	//
	UspAnalyze(
		uspData, 
		hdcTemp, 
		buff, 
		len, 
		attr, 
		0, 
		m_uspFontList,
		&scriptControl, 
		&scriptState, 
		&tabdef
	);

	//
	//	Modify CR/LF so cursor cannot traverse into them
	//
	//MarkCRLF(uspData, buff, len, attr);

	//
	//	Apply the selection
	//
	ApplySelection(uspData, nLineNo, off_chars, len);

	if(hdc == 0)
		ReleaseDC(m_hwnd, hdcTemp);

	if(nOffset)
		*nOffset = off_chars;

	return &m_uspCache[lru_index];
}

bool CTextEditor::GetLogAttr (ULONG nLineNo, USPCACHE** puspCache, CSCRIPT_LOGATTR** plogAttr, ULONG* pnOffset)
{
	if((*puspCache = GetUspCache(0, nLineNo, pnOffset)) == 0)
		return false;

	if(plogAttr && (*plogAttr = UspGetLogAttr((*puspCache)->uspData)) == 0)
		return false;

	return true;
}

INT CTextEditor::LeftMarginWidth (VOID)
{
	INT xSize = 0;

	if(CheckStyle(TXS_SELMARGIN))
		xSize += 10;
	if(CheckStyle(TXS_LEFTMARGIN))
		xSize += m_nLineHeight + 5;

	return xSize;
}

void CTextEditor::PaintLine (HDC hdc, ULONG nLineNo, int xpos, int ypos, HRGN hrgnUpdate)
{
	RECT	bounds;
	HRGN	hrgnBounds;
	INT		xLeftMargin = LeftMarginWidth();

	GetClientRect(m_hwnd, &bounds);
	SelectClipRgn(hdc, NULL);

	// no point in drawing outside the window-update-region
	if(hrgnUpdate != NULL)
	{
		// work out where the line would have been on-screen
		bounds.left     = (long)(-m_nHScrollPos * m_nFontWidth + xLeftMargin);
		bounds.top		= (long)((nLineNo - m_nVScrollPos) * m_nLineHeight);
		bounds.right	= (long)(bounds.right);
		bounds.bottom	= (long)(bounds.top + m_nLineHeight);
		
		//	clip the window update-region with the line's bounding rectangle
		hrgnBounds = CreateRectRgnIndirect(&bounds);
		CombineRgn(hrgnBounds, hrgnUpdate, hrgnBounds, RGN_AND);
		
		// work out the bounding-rectangle of this intersection
		GetRgnBox(hrgnBounds, &bounds);
		bounds.top		= 0;
		bounds.bottom	= m_nLineHeight;
	}

	PaintText(hdc, nLineNo, xpos + xLeftMargin, ypos, &bounds);

	DeleteObject(hrgnBounds);
	SelectClipRgn(hdc, NULL);

	//
	//	draw the margin straight over the top
	//
	if(0 < xLeftMargin)
	{
		RECT rcMargin = { 0, 0, xLeftMargin, m_nLineHeight };
		PaintMargin(hdc, nLineNo, rcMargin);
	}
}

void CTextEditor::PaintText (HDC hdc, ULONG nLineNo, int xpos, int ypos, RECT* bounds)
{
	USPDATA* uspData;
	ULONG lineOffset;

	// grab the USPDATA for this line
	uspData = GetUspData(hdc, nLineNo, &lineOffset);

	// set highlight-colors depending on window-focus
	if(GetFocus() == m_hwnd)
		UspSetSelColor(uspData, GetColor(TXC_HIGHLIGHTTEXT), GetColor(TXC_HIGHLIGHT));
	else
		UspSetSelColor(uspData, GetColor(TXC_HIGHLIGHTTEXT2), GetColor(TXC_HIGHLIGHT2));

	// update selection-attribute information for the line
	UspApplySelection(uspData, m_nSelectionStart - lineOffset, m_nSelectionEnd - lineOffset);

	ApplySelection(uspData, nLineNo, lineOffset, uspData->stringLen);

	// draw the text!
	UspTextOut(uspData, hdc, xpos, ypos, m_nLineHeight, m_nHeightAbove, bounds);
}

void CTextEditor::PaintMargin (HDC hdc, ULONG nLineNo, const RECT& rcMargin)
{
	DRAWITEMSTRUCT di;
	RECT rcBackground = rcMargin;
	RECT rcBorder = rcMargin;

	rcBackground.right -= 2;
	rcBorder.left = rcBackground.right;
	rcBorder.right = rcBorder.left + 1;

	PaintRect(hdc, rcBackground, GetColor(TXC_MARGIN));
	PaintRect(hdc, rcBorder, GetColor(TXC_MARGIN_BORDER));

	di.CtlType = ODT_STATIC;
	di.CtlID = GetDlgCtrlID(m_hwnd);
	di.itemID = nLineNo;
	di.itemAction = ODA_DRAWENTIRE;
	di.itemState = ODS_DEFAULT;
	di.hwndItem = m_hwnd;
	di.hDC = hdc;
	di.rcItem = rcMargin;
	di.itemData = reinterpret_cast<ULONG_PTR>(m_pTextDoc);
	SendMessage(GetParent(m_hwnd), WM_DRAWITEM, 0, (LPARAM)&di);
}

int	CTextEditor::ApplySelection (USPDATA* uspData, ULONG nLine, ULONG nOffset, ULONG nTextLen)
{
	int selstart = 0;
	int selend   = 0;

	if(m_nSelectionType != SEL_BLOCK)
		return 0;

	if(nLine >= m_cpBlockStart.line && nLine <= m_cpBlockEnd.line)
	{
		int trailing;

		UspXToOffset(uspData, m_cpBlockStart.xpos, &selstart, &trailing, 0);
		selstart += trailing;

		UspXToOffset(uspData, m_cpBlockEnd.xpos, &selend, &trailing, 0);
		selend += trailing;

		if(selstart > selend)
			selstart ^= selend ^= selstart^= selend;
	}

	UspApplySelection(uspData, selend, selstart);

	return 0;
}

int CTextEditor::ApplyTextAttributes (ULONG nLineNo, ULONG nOffset, ULONG &nColumn, PWSTR szText, int nTextLen, ATTR* attr)
{
	int i;

	ULONG selstart = min(m_nSelectionStart, m_nSelectionEnd);
	ULONG selend   = max(m_nSelectionStart, m_nSelectionEnd);

	//
	//	STEP 1. Apply the "base coat"
	//
	for(i = 0; i < nTextLen; i++)
	{
		attr[i].len		 = 1;
		attr[i].font	 = 0;
		attr[i].eol		 = 0;
		attr[i].reserved = 0;

		// change the background if the line is too long
		if(nColumn >= (ULONG)m_nLongLineLimit && CheckStyle(TXS_LONGLINES))
		{
			attr[i].fg = GetColor(TXC_FOREGROUND);
			attr[i].bg = LongColor(nLineNo);
		}
		else
		{
			attr[i].fg = GetColor(TXC_FOREGROUND);
			attr[i].bg = LineColor(nLineNo);//GetColor(TXC_BACKGROUND);
		}

		// keep track of how many columns we have processed
		if(szText[i] == '\t')
		{
			INT nTabWidth = m_pTextDoc->GetTabWidth();
			nColumn += nTabWidth - (nColumn % nTabWidth);
		}
		else
			nColumn += 1;
	}

	//
	//	TODO: 1. Apply syntax coloring first of all
	//

	//
	//	TODO: 2. Apply bookmarks, line highlighting etc (override syntax coloring)
	//

	//
	//	STEP 3:  Now apply text-selection (overrides everything else)
	//
	if(m_nSelectionType == SEL_NORMAL)
	{
		for(i = 0; i < nTextLen; i++)
		{
			// highlight uses a separate attribute-flag
			if(nOffset + i >= selstart && nOffset + i < selend)
				attr[i].sel = 1;
			else
				attr[i].sel = 0;
		}
	}
	else if(m_nSelectionType == SEL_BLOCK)
	{
	}

	{
		TVNSYNTAXHIGHLIGHT syntax;
		syntax.nLineNo = nLineNo;
		syntax.pcwzText = szText;
		syntax.nTextLen = nTextLen;
		syntax.pAttr = attr;
		NotifyParent(TVN_SYNTAX_HIGHLIGHT, &syntax);
	}

	//
	//	Turn any CR/LF at the end of a line into a single 'space' character
	//
	nTextLen = StripCRLF(szText, attr, nTextLen, false);

	//
	//	Finally identify control-characters (after CR/LF has been changed to 'space')
	//

	for(i = 0; i < nTextLen; i++)
	{
		ULONG ch = szText[i];
		attr[i].ctrl = ch < 0x20 ? 1 : 0;
		if(ch == '\r' || ch == '\n')
			attr[i].eol=TRUE;
	}

	return nTextLen;
}

VOID CTextEditor::SetupScrollbars ()
{
	SCROLLINFO si = { sizeof(si) };

	si.fMask = SIF_PAGE | SIF_POS | SIF_RANGE | SIF_DISABLENOSCROLL;

	//
	//	Vertical scrollbar
	//
	si.nPos  = m_nVScrollPos;		// scrollbar thumb position
	si.nPage = m_nWindowLines;		// number of lines in a page
	si.nMin  = 0;					
	si.nMax  = m_pTextDoc->LineCount() - 1;	// total number of lines in file
	
	SetScrollInfo(m_hwnd, SB_VERT, &si, TRUE);

	//
	//	Horizontal scrollbar
	//
	si.nPos  = m_nHScrollPos;		// scrollbar thumb position
	si.nPage = m_nWindowColumns;	// number of lines in a page
	si.nMin  = 0;
	si.nMax  = m_pTextDoc->LongestLine() - 1;	// total number of lines in file

	SetScrollInfo(m_hwnd, SB_HORZ, &si, TRUE);

	// adjust our interpretation of the max scrollbar range to make
	// range-checking easier. The scrollbars don't use these values, they
	// are for our own use.
	m_nVScrollMax = m_pTextDoc->LineCount() - m_nWindowLines;
	m_nHScrollMax = m_pTextDoc->LongestLine() - m_nWindowColumns;
}

//
//	Ensure that we never scroll off the end of the file
//
bool CTextEditor::PinToBottomCorner ()
{
	bool repos = false;

	if(static_cast<size_w>(m_nHScrollPos + m_nWindowColumns) > m_pTextDoc->LongestLine())
	{
		m_nHScrollPos = m_pTextDoc->LongestLine() - m_nWindowColumns;
		repos = true;
	}

	if(static_cast<ULONG>(m_nVScrollPos + m_nWindowLines) > m_pTextDoc->LineCount())
	{
		m_nVScrollPos = m_pTextDoc->LineCount() - m_nWindowLines;
		repos = true;
	}

	return repos;
}

VOID CTextEditor::UpdateCaretOffset (ULONG offset, BOOL fTrailing, int* outx, ULONG* outlineno)
{
	ULONG		lineno = 0;
	int			xpos = 0;
	ULONG		off_chars;
	USPDATA	  * uspData;

	// get line information from cursor-offset
	if(m_pTextDoc->GetLineFromOffset(offset, &lineno, &off_chars))
	{
		// locate the USPDATA for this line
		if((uspData = GetUspData(NULL, lineno)) != 0)
		{	
			// convert character-offset to x-coordinate
			off_chars = m_nCursorOffset - off_chars;
			
			if(fTrailing && off_chars > 0)
				UspOffsetToX(uspData, off_chars-1, TRUE, &xpos);
			else
				UspOffsetToX(uspData, off_chars, FALSE, &xpos);

			// update caret position
			UpdateCaretXY(xpos, lineno);
		}
	}

	if(outx)	  *outx = xpos;
	if(outlineno) *outlineno = lineno;
}

VOID CTextEditor::UpdateCaretXY (int xpos, ULONG lineno)
{
	bool visible = false;

	// convert x-coord to window-relative
	xpos -= m_nHScrollPos * m_nFontWidth;
	xpos += LeftMarginWidth();

	// only show caret if it is visible within viewport
	if(lineno >= m_nVScrollPos && lineno <= m_nVScrollPos + m_nWindowLines)
	{
		if(xpos >= LeftMarginWidth())
			visible = true;
	}

	// hide caret if it was previously visible
	if(visible == false && m_fHideCaret == false)
	{
		m_fHideCaret = true;
		HideCaret(m_hwnd);
	}
	// show caret if it was previously hidden
	else if(visible == true && m_fHideCaret == true)
	{
		m_fHideCaret = false;
		ShowCaret(m_hwnd);
	}

	// set caret position if within window viewport
	if(m_fHideCaret == false)
	{
		SetCaretPos(xpos, (lineno - m_nVScrollPos) * m_nLineHeight);
	}
}

VOID CTextEditor::RepositionCaret ()
{
	UpdateCaretXY(m_nCaretPosX, m_nCurrentLine);
}

VOID CTextEditor::UpdateView (bool fAdvancing)
{
	// This method was called "Smeg" in Neatpad
	ULONG nLine;

	UpdateMetrics();
	SetupScrollbars();

	UpdateCaretOffset(m_nCursorOffset, fAdvancing, &m_nCaretPosX, &nLine);
	UpdateLine(nLine);

	m_nAnchorPosX = m_nCaretPosX;
	ScrollToPosition(m_nCaretPosX, m_nCurrentLine);
	RepositionCaret();
}

INT CTextEditor::GetCurrentColumn ()
{
	ULONG nOffset;
	GetUspData(0, m_nCurrentLine, &nOffset);
	return m_nCursorOffset - nOffset;
}

LONG CTextEditor::InvalidateRange (ULONG nStart, ULONG nFinish)
{
	ULONG start  = min(nStart, nFinish);
	ULONG finish = max(nStart, nFinish);
	
	int   ypos;
	RECT  rect;
	RECT  client;
	CTextIterator itor;

	// information about current line:
	ULONG lineno;
	ULONG off_chars;
	ULONG len_chars;

	// nothing to do?
	if(start == finish)
		return 0;

	//
	//	Find the start-of-line information from specified file-offset
	//
	m_pTextDoc->GetLineFromOffset(start, &lineno, NULL);

	// clip to top of window
	if(lineno < m_nVScrollPos)
	{
		lineno = m_nVScrollPos;
		itor   = static_cast<CTextDocument*>(m_pTextDoc)->IterateLine(lineno, &off_chars, &len_chars);
		start  = off_chars;
	}
	else
	{
		itor   = static_cast<CTextDocument*>(m_pTextDoc)->IterateLine(lineno, &off_chars, &len_chars);
	}

	if(!itor || start >= finish)
		return 0;

	ypos = (lineno - m_nVScrollPos) * m_nLineHeight;
	GetClientRect(m_hwnd, &client);

	// invalidate *whole* lines. don't care about flickering anymore because
	// all output is double-buffered now, and this method is much simpler
	while(itor && off_chars < finish)
	{
		SetRect(&rect, 0, ypos, client.right, ypos + m_nLineHeight);
		rect.left -= m_nHScrollPos * m_nFontWidth;
		rect.left += LeftMarginWidth();

		InvalidateRect(m_hwnd, &rect, FALSE);

		// jump down to next line
		itor  = static_cast<CTextDocument*>(m_pTextDoc)->IterateLine(++lineno, &off_chars, &len_chars);
		ypos += m_nLineHeight;
	}

	return 0;
}

LONG CTextEditor::InvalidateLine (ULONG nLineNo, bool forceAnalysis)
{
	if(nLineNo >= m_nVScrollPos && nLineNo <= m_nVScrollPos + m_nWindowLines)
	{
		RECT rect;

		GetClientRect(m_hwnd, &rect);

		rect.top    = (nLineNo - m_nVScrollPos) * m_nLineHeight;
		rect.bottom = rect.top + m_nLineHeight;
	
		InvalidateRect(m_hwnd, &rect, FALSE);
	}

	if(forceAnalysis)
	{
		for(int i = 0; i < USP_CACHE_SIZE; i++)
		{
			if(nLineNo == m_uspCache[i].lineno)
			{
				m_uspCache[i].usage = 0;
				break;
			}
		}
	}

	return 0;
}

void CTextEditor::UpdateLine (ULONG nLineNo)
{
	// redraw the old and new lines if they are different
	if(m_nCurrentLine != nLineNo)
	{
		if(CheckStyle(TXS_HIGHLIGHTCURLINE))
			InvalidateLine(m_nCurrentLine, true);

		m_nCurrentLine = nLineNo;

		if(CheckStyle(TXS_HIGHLIGHTCURLINE))
			InvalidateLine(m_nCurrentLine, true);
	}
}

VOID CTextEditor::FinalizeNavigation (UINT nKeyCode, BOOL fShiftDown, BOOL fCtrlDown, BOOL fAdvancing)
{
	ULONG nLine;

	// Extend selection if <shift> is down
	if(fShiftDown)
	{		
		InvalidateRange(m_nSelectionEnd, m_nCursorOffset);
		m_nSelectionEnd	= m_nCursorOffset;
	}
	// Otherwise clear the selection
	else
	{
		if(m_nSelectionStart != m_nSelectionEnd)
			InvalidateRange(m_nSelectionStart, m_nSelectionEnd);

		m_nSelectionEnd		= m_nCursorOffset;
		m_nSelectionStart	= m_nCursorOffset;
	}

	// update caret-location (xpos, line#) from the offset
	UpdateCaretOffset(m_nCursorOffset, fAdvancing, &m_nCaretPosX, &nLine);
	UpdateLine(nLine);

	// maintain the caret 'anchor' position *except* for up/down actions
	if(nKeyCode != VK_UP && nKeyCode != VK_DOWN)
	{
		m_nAnchorPosX = m_nCaretPosX;

		// scroll as necessary to keep caret within viewport
		ScrollToPosition(m_nCaretPosX, m_nCurrentLine);
	}
	else
	{
		// scroll as necessary to keep caret within viewport
		if(!fCtrlDown)
			ScrollToPosition(m_nCaretPosX, m_nCurrentLine);
	}

	TVNCURSORINFO ci;
	ci.nLineNo = m_nCurrentLine;
	ci.nColumnNo = GetCurrentColumn();
	ci.nOffset = m_nCursorOffset;
	NotifyParent(TVN_CURSOR_CHANGE, &ci);
}

VOID CTextEditor::MouseCoordToFilePos (int mx, int my, ULONG* pnLineNo, ULONG* pnFileOffset, int* psnappedX)
{
	ULONG nLineNo;
	ULONG off_chars, cchLine;
	RECT  rect;
	int	  cp;

	// get scrollable area
	GetClientRect(m_hwnd, &rect);
	rect.bottom -= rect.bottom % m_nLineHeight;

	// take left margin into account
	mx -= LeftMarginWidth();

	// clip mouse to edge of window
	if(mx < 0)				mx = 0;
	if(my < 0)				my = 0;
	if(my >= rect.bottom)	my = rect.bottom - 1;
	if(mx >= rect.right)	mx = rect.right  - 1;

	// It's easy to find the line-number: just divide 'y' by the line-height
	nLineNo = (my / m_nLineHeight) + m_nVScrollPos;

	// make sure we don't go outside of the document
	if(nLineNo >= m_pTextDoc->LineCount())
	{
		nLineNo   = m_pTextDoc->LineCount() ? m_pTextDoc->LineCount() - 1 : 0;
		off_chars = m_pTextDoc->Size();
	}

	mx += m_nHScrollPos * m_nFontWidth;

	// get the USPDATA object for the selected line!!
	USPDATA *uspData = GetUspData(0, nLineNo);

	// convert mouse-x coordinate to a character-offset relative to start of line
	UspSnapXToOffset(uspData, mx, &mx, &cp, 0);

	// return coords!
	CTextIterator itor = static_cast<CTextDocument*>(m_pTextDoc)->IterateLine(nLineNo, &off_chars, &cchLine);
	*pnLineNo		= nLineNo;
	*pnFileOffset	= cp + off_chars;
	*psnappedX		= mx;// - m_nHScrollPos * m_nFontWidth;
	//*psnappedX		+= LeftMarginWidth();
}

HMENU CTextEditor::CreateContextMenu (VOID)
{
	HMENU hMenu = CreatePopupMenu();

	// do we have a selection?
	UINT fSelection = (m_nSelectionStart == m_nSelectionEnd) ?
		MF_DISABLED| MF_GRAYED : MF_ENABLED;

	// is there text on the clipboard?
	UINT fClipboard = (IsClipboardFormatAvailable(CF_TEXT) || IsClipboardFormatAvailable(CF_UNICODETEXT)) ?
		MF_ENABLED : MF_GRAYED | MF_DISABLED;

	UINT fCanUndo = CanUndo() ? MF_ENABLED : MF_GRAYED | MF_DISABLED;
	UINT fCanRedo = CanRedo() ? MF_ENABLED : MF_GRAYED | MF_DISABLED;

	AppendMenu(hMenu, MF_STRING|fCanUndo,				ID_EDIT_UNDO,		L"&Undo");
	AppendMenu(hMenu, MF_STRING|fCanRedo,				ID_EDIT_REDO,		L"&Redo");
	AppendMenu(hMenu, MF_SEPARATOR,						0, 0);
	AppendMenu(hMenu, MF_STRING|fSelection,				ID_EDIT_CUT,		L"Cu&t");
	AppendMenu(hMenu, MF_STRING|fSelection,				ID_EDIT_COPY,		L"&Copy");
	AppendMenu(hMenu, MF_STRING|fClipboard,				ID_EDIT_PASTE,		L"&Paste");
	AppendMenu(hMenu, MF_STRING|fSelection,				ID_EDIT_CLEAR,		L"&Delete");
	AppendMenu(hMenu, MF_SEPARATOR,						0, 0);
	AppendMenu(hMenu, MF_STRING|MF_ENABLED,				ID_EDIT_SELECT_ALL,	L"&Select All");

	return hMenu;
}

VOID CTextEditor::MoveWordPrev ()
{
	USPCACHE		* uspCache;
	CSCRIPT_LOGATTR * logAttr;
	ULONG			  lineOffset;
	int				  charPos;

	// get Uniscribe data for current line
	if(!GetLogAttr(m_nCurrentLine, &uspCache, &logAttr, &lineOffset))
		return;

	// move 1 character to left
	charPos = m_nCursorOffset - lineOffset - 1; 

	// skip to end of *previous* line if necessary
	if(charPos < 0)
	{
		charPos = 0;

		if(m_nCurrentLine > 0)
		{
			MoveLineEnd(m_nCurrentLine - 1);
			return;
		}
	}

	// skip preceding whitespace
	while(charPos > 0 && logAttr[charPos].fWhiteSpace)
		charPos--;

	// skip whole characters until we hit a word-break/more whitespace
	for( ; charPos > 0 ; charPos--)
	{
		if(logAttr[charPos].fWordStop || logAttr[charPos-1].fWhiteSpace)
			break;
	}

	m_nCursorOffset = lineOffset + charPos;
}

VOID CTextEditor::MoveWordNext ()
{
	USPCACHE		* uspCache;
	CSCRIPT_LOGATTR * logAttr;
	ULONG			  lineOffset;
	int				  charPos;

	// get Uniscribe data for current line
	if(!GetLogAttr(m_nCurrentLine, &uspCache, &logAttr, &lineOffset))
		return;

	charPos = m_nCursorOffset - lineOffset;

	// if already at end-of-line, skip to next line
	if(charPos == uspCache->length_CRLF)
	{
		if(m_nCurrentLine + 1 < m_pTextDoc->LineCount())
			MoveLineStart(m_nCurrentLine + 1);

		return;
	}

	// if already on a word-break, go to next char
	if(logAttr[charPos].fWordStop)
		charPos++;

	// skip whole characters until we hit a word-break/more whitespace
	for( ; charPos < uspCache->length_CRLF; charPos++)
	{
		if(logAttr[charPos].fWordStop || logAttr[charPos].fWhiteSpace)
			break;
	}

	// skip trailing whitespace
	while(charPos < uspCache->length_CRLF && logAttr[charPos].fWhiteSpace)
		charPos++;

	m_nCursorOffset = lineOffset + charPos;
}

VOID CTextEditor::MoveWordStart ()
{
	USPCACHE		* uspCache;
	CSCRIPT_LOGATTR * logAttr;
	ULONG			  lineOffset;
	int				  charPos;

	// get Uniscribe data for current line
	if(GetLogAttr(m_nCurrentLine, &uspCache, &logAttr, &lineOffset))
	{
		charPos  = m_nCursorOffset - lineOffset;

		while(charPos > 0 && !logAttr[charPos-1].fWhiteSpace)
			charPos--;

		m_nCursorOffset = lineOffset + charPos;
	}
}

VOID CTextEditor::MoveWordEnd ()
{
	USPCACHE		* uspCache;
	CSCRIPT_LOGATTR * logAttr;
	ULONG			  lineOffset;
	int				  charPos;

	// get Uniscribe data for current line
	if(GetLogAttr(m_nCurrentLine, &uspCache, &logAttr, &lineOffset))
	{
		charPos  = m_nCursorOffset - lineOffset;

		while(charPos < uspCache->length_CRLF && !logAttr[charPos].fWhiteSpace)
			charPos++;

		m_nCursorOffset = lineOffset + charPos;
	}
}

VOID CTextEditor::MoveCharPrev ()
{
	USPCACHE		* uspCache;
	CSCRIPT_LOGATTR * logAttr;
	ULONG			  lineOffset;
	int				  charPos;

	// get Uniscribe data for current line
	if(!GetLogAttr(m_nCurrentLine, &uspCache, &logAttr, &lineOffset))
		return;

	charPos = m_nCursorOffset - lineOffset;

	// find the previous valid character-position
	for( --charPos; charPos >= 0; charPos--)
	{
		if(logAttr[charPos].fCharStop)
			break;
	}

	// move up to end-of-last line if necessary
	if(charPos < 0)
	{
		charPos  = 0;

		if(m_nCurrentLine > 0)
		{
			MoveLineEnd(m_nCurrentLine - 1);
			return;
		}
	}

	// update cursor position
	m_nCursorOffset = lineOffset + charPos;
}

VOID CTextEditor::MoveCharNext ()
{
	USPCACHE		* uspCache;
	CSCRIPT_LOGATTR * logAttr;
	ULONG			  lineOffset;
	int				  charPos;

	// get Uniscribe data for specified line
	if(!GetLogAttr(m_nCurrentLine, &uspCache, &logAttr, &lineOffset))
		return;

	charPos = m_nCursorOffset - lineOffset;

	// find the next valid character-position
	for( ++charPos; charPos <= uspCache->length_CRLF; charPos++)
	{
		if(logAttr[charPos].fCharStop)
			break;
	}

	// skip to beginning of next line if we hit the CR/LF
	if(charPos > uspCache->length_CRLF)
	{
		if(m_nCurrentLine + 1 < m_pTextDoc->LineCount())
			MoveLineStart(m_nCurrentLine+1);
	}
	// otherwise advance the character-position
	else
	{
		m_nCursorOffset = lineOffset + charPos;
	}
}

VOID CTextEditor::MoveLineUp (int numLines)
{
	USPDATA			* uspData;
	ULONG			  lineOffset;
	
	int				  charPos;
	BOOL			  trailing;

	UpdateLine(m_nCurrentLine - min(m_nCurrentLine, (unsigned)numLines));

	// get Uniscribe data for prev line
	uspData = GetUspData(0, m_nCurrentLine, &lineOffset);

	// move up to character nearest the caret-anchor positions
	UspXToOffset(uspData, m_nAnchorPosX, &charPos, &trailing, 0);

	m_nCursorOffset = lineOffset + charPos + trailing;
}

VOID CTextEditor::MoveLineDown (int numLines)
{
	USPDATA			* uspData;
	ULONG			  lineOffset;
	
	int				  charPos;
	BOOL			  trailing;

	UpdateLine(m_nCurrentLine + min(m_pTextDoc->LineCount() - m_nCurrentLine - 1, (unsigned)numLines));

	// get Uniscribe data for prev line
	uspData = GetUspData(0, m_nCurrentLine, &lineOffset);

	// move down to character nearest the caret-anchor position
	UspXToOffset(uspData, m_nAnchorPosX, &charPos, &trailing, 0);

	m_nCursorOffset = lineOffset + charPos + trailing;
}

VOID CTextEditor::MoveLineStart (ULONG lineNo)
{
	ULONG			  lineOffset;
	USPCACHE		* uspCache;
	CSCRIPT_LOGATTR * logAttr;
	int				  charPos;
	
	// get Uniscribe data for current line
	if(!GetLogAttr(lineNo, &uspCache, &logAttr, &lineOffset))
		return;

	charPos  = m_nCursorOffset - lineOffset;
	
	// if already at start of line, skip *forwards* past any whitespace
	if(m_nCursorOffset == lineOffset)
	{
		// skip whitespace
		while(logAttr[m_nCursorOffset - lineOffset].fWhiteSpace)
			m_nCursorOffset++;
	}
	// if not at start, goto start
	else
	{
		m_nCursorOffset = lineOffset;
	}
}

VOID CTextEditor::MoveLineEnd (ULONG lineNo)
{
	USPCACHE *uspCache;
	
	if((uspCache = GetUspCache(0, lineNo)) == 0)
		return;

	m_nCursorOffset = uspCache->offset + uspCache->length_CRLF;
}

VOID CTextEditor::MoveFileStart ()
{
	m_nCursorOffset = 0;
}

VOID CTextEditor::MoveFileEnd ()
{
	m_nCursorOffset = m_pTextDoc->Size();
}

VOID CTextEditor::UpdateMetrics ()
{
	RECT rect;
	GetClientRect(m_hwnd, &rect);

	SizeEditor(0, rect.right, rect.bottom);
	RefreshWindow();

	RepositionCaret();
}

VOID CTextEditor::RecalcLineHeight ()
{
	m_nLineHeight	= 0;
	m_nMaxAscent	= 0;

	// find the tallest font in the TextView
	for(int i = 0; i < m_nNumFonts; i++)
	{
		// always include a font's external-leading
		int fontheight = m_uspFontList[i].tm.tmHeight + 
						 m_uspFontList[i].tm.tmExternalLeading;

		m_nLineHeight = max(m_nLineHeight, fontheight);
		m_nMaxAscent  = max(m_nMaxAscent, m_uspFontList[i].tm.tmAscent);
	}

	// add on the above+below spacings
	m_nLineHeight += m_nHeightAbove + m_nHeightBelow;

	// force caret resize if we've got the focus
	if(GetFocus() == m_hwnd)
	{
		OnKillFocus(0);
		OnSetFocus(0);
	}
}

VOID CTextEditor::SetFont (HFONT hFont, int idx)
{
	USPFONT* uspFont = &m_uspFontList[idx];

	// need a DC to query font data
	HDC hdc = GetDC(m_hwnd);

	// Initialize the font for USPLIB
	UspFreeFont(uspFont);
	UspInitFont(uspFont, hdc, hFont);

	ReleaseDC(m_hwnd, hdc);

	// calculate new line metrics
	m_nFontWidth = m_uspFontList[0].tm.tmAveCharWidth;

	RecalcLineHeight();
	ResetLineCache();
}

LRESULT CTextEditor::SizeEditor (UINT nFlags, int width, int height)
{
	int margin = LeftMarginWidth();

	m_nWindowLines   = min((unsigned)height	/ m_nLineHeight, m_pTextDoc->LineCount());
	m_nWindowColumns = min((width - margin)	/ m_nFontWidth,  static_cast<INT>(m_pTextDoc->LongestLine()));

	if(PinToBottomCorner())
	{
		RefreshWindow();
		RepositionCaret();
	}

	SetupScrollbars();

	return 0;
}

//
//	ScrollRgn
//
//	Scrolls the viewport in specified direction. If fReturnUpdateRgn is true, 
//	then a HRGN is returned which holds the client-region that must be redrawn 
//	manually. This region must be deleted by the caller using DeleteObject.
//
//  Otherwise ScrollRgn returns NULL and updates the entire window 
//
HRGN CTextEditor::ScrollRgn (int dx, int dy, bool fReturnUpdateRgn)
{
	RECT clip;

	GetClientRect(m_hwnd, &clip);

	//
	// make sure that dx,dy don't scroll us past the edge of the document!
	//

	// scroll up
	if(dy < 0)
	{
		dy = -(int)min((ULONG)-dy, m_nVScrollPos);
		clip.top = -dy * m_nLineHeight;
	}
	// scroll down
	else if(dy > 0)
	{
		dy = min((ULONG)dy, m_nVScrollMax-m_nVScrollPos);
		clip.bottom = (m_nWindowLines -dy) * m_nLineHeight;
	}

	// scroll left
	if(dx < 0)
	{
		dx = -(int)min(-dx, m_nHScrollPos);
		clip.left = -dx * m_nFontWidth * 4;
	}
	// scroll right
	else if(dx > 0)
	{
		dx = min((unsigned)dx, (unsigned)m_nHScrollMax-m_nHScrollPos);
		clip.right = (m_nWindowColumns - dx - 4) * m_nFontWidth ;
	}

	// adjust the scrollbar thumb position
	m_nHScrollPos += dx;
	m_nVScrollPos += dy;

	// ignore clipping rectangle if its a whole-window scroll
	if(fReturnUpdateRgn == false)
		GetClientRect(m_hwnd, &clip);

	// take margin into account
	clip.left += LeftMarginWidth();

	// perform the scroll
	if(dx != 0 || dy != 0)
	{
		// do the scroll!
		ScrollWindowEx(
			m_hwnd, 
			-dx * m_nFontWidth,					// scale up to pixel coords
			-dy * m_nLineHeight,
			NULL,								// scroll entire window
			&clip,								// clip the non-scrolling part
			0, 
			0, 
			SW_INVALIDATE
			);

		SetupScrollbars();

		if(fReturnUpdateRgn)
		{
			RECT client;

			GetClientRect(m_hwnd, &client);

			//clip.left -= LeftMarginWidth();

			HRGN hrgnClient  = CreateRectRgnIndirect(&client);
			HRGN hrgnUpdate  = CreateRectRgnIndirect(&clip);

			// create a region that represents the area outside the
			// clipping rectangle (i.e. the part that is never scrolled)
			CombineRgn(hrgnUpdate, hrgnClient, hrgnUpdate, RGN_XOR);

			DeleteObject(hrgnClient);

			return hrgnUpdate;
		}
	}

	if(dy != 0)
	{
		GetClientRect(m_hwnd, &clip);
		clip.right = LeftMarginWidth();
		//ScrollWindow(m_hwnd, 0, -dy * m_nLineHeight, 0, &clip);
		InvalidateRect(m_hwnd, &clip, 0);
	}

	return NULL;
}

//
//	Scroll viewport in specified direction
//
VOID CTextEditor::Scroll (int dx, int dy)
{
	// do a "normal" scroll - don't worry about invalid regions,
	// just scroll the whole window 
	ScrollRgn(dx, dy, false);
}

//
//	Ensure that the specified file-location is visible within
//  the window-viewport, Scrolling the viewport as necessary
//
VOID CTextEditor::ScrollToPosition (int xpos, ULONG lineno)
{
	bool fRefresh = false;
	RECT rect;
	int  marginWidth = LeftMarginWidth();

	GetClientRect(m_hwnd, &rect);

	xpos -= m_nHScrollPos * m_nFontWidth;
	xpos += marginWidth;
	
	if(xpos < marginWidth)
	{
		m_nHScrollPos -= (marginWidth - xpos) / m_nFontWidth;
		fRefresh = true;
	}

	if(xpos >= rect.right)
	{
		m_nHScrollPos += (xpos - rect.right) / m_nFontWidth + 1;
		fRefresh = true;
	}
	
	if(lineno < m_nVScrollPos)
	{
		m_nVScrollPos = lineno;
		fRefresh = true;
	}
	else if(lineno > m_nVScrollPos + m_nWindowLines - 1)
	{
		m_nVScrollPos = lineno - m_nWindowLines + 1;
		fRefresh = true;
	}

	if(fRefresh)
	{
		SetupScrollbars();
		RefreshWindow();
		RepositionCaret();
	}
}

VOID CTextEditor::ScrollToCaret()
{
	ScrollToPosition(m_nCaretPosX, m_nCurrentLine);
}

LONG CTextEditor::GetTrackPos32 (HWND hwnd, int nBar)
{
	SCROLLINFO si = { sizeof(si), SIF_TRACKPOS };
	GetScrollInfo(hwnd, nBar, &si);
	return si.nTrackPos;
}

bool CTextEditor::IsKeyPressed (UINT nVirtKey)
{
	return GetKeyState(nVirtKey) < 0 ? true : false;
}

LRESULT CTextEditor::OnSize (UINT nFlags, int width, int height)
{
	return SizeEditor(nFlags, width, height);
}

LRESULT CTextEditor::OnVScroll (UINT nSBCode, UINT nPos)
{
	ULONG oldpos = m_nVScrollPos;

	switch(nSBCode)
	{
	case SB_TOP:
		m_nVScrollPos = 0;
		RefreshWindow();
		break;

	case SB_BOTTOM:
		m_nVScrollPos = m_nVScrollMax;
		RefreshWindow();
		break;

	case SB_LINEUP:
		Scroll(0, -1);
		break;

	case SB_LINEDOWN:
		Scroll(0, 1);
		break;

	case SB_PAGEDOWN:
		Scroll(0, m_nWindowLines);
		break;

	case SB_PAGEUP:
		Scroll(0, -m_nWindowLines);
		break;

	case SB_THUMBPOSITION:
	case SB_THUMBTRACK:
		m_nVScrollPos = GetTrackPos32(m_hwnd, SB_VERT);
		RefreshWindow();
		break;
	}

	if(oldpos != m_nVScrollPos)
	{
		SetupScrollbars();
		RepositionCaret();
	}

	return 0;
}

LRESULT CTextEditor::OnHScroll (UINT nSBCode, UINT nPos)
{
	int oldpos = m_nHScrollPos;

	switch(nSBCode)
	{
	case SB_LEFT:
		m_nHScrollPos = 0;
		RefreshWindow();
		break;

	case SB_RIGHT:
		m_nHScrollPos = m_nHScrollMax;
		RefreshWindow();
		break;

	case SB_LINELEFT:
		Scroll(-1, 0);
		break;

	case SB_LINERIGHT:
		Scroll(1, 0);
		break;

	case SB_PAGELEFT:
		Scroll(-m_nWindowColumns, 0);
		break;

	case SB_PAGERIGHT:
		Scroll(m_nWindowColumns, 0);
		break;

	case SB_THUMBPOSITION:
	case SB_THUMBTRACK:
		m_nHScrollPos = GetTrackPos32(m_hwnd, SB_HORZ);
		RefreshWindow();
		break;
	}

	if(oldpos != m_nHScrollPos)
	{
		SetupScrollbars();
		RepositionCaret();
	}

	return 0;
}

LRESULT CTextEditor::OnMouseActivate (HWND hwndTop, UINT nHitTest, UINT nMessage)
{
	::SetFocus(m_hwnd);
	return MA_ACTIVATE;
}

LRESULT CTextEditor::OnContextMenu (HWND wParam, int x, int y)
{
	TVNMCONTEXTMENU cm;
	cm.hMenu = CreateContextMenu();
	if(cm.hMenu)
	{
		TVNMCLOSECONTEXT	cc;
		USPCACHE*			uspCache;
		CSCRIPT_LOGATTR*	logAttr;
		ULONG				lineOffset;

		cm.ptClient.x = x;
		cm.ptClient.y = y;
		cm.pcwzWord = NULL;
		cm.nWordOffset = (ULONG)-1;
		cm.pvUserParam = NULL;
		ScreenToClient(m_hwnd, &cm.ptClient);
		MouseCoordToFilePos(cm.ptClient.x, cm.ptClient.y, &cm.nLine, &cm.nOffset, &cm.xCaretPos);

		// get Uniscribe data for current line
		if(GetLogAttr(cm.nLine, &uspCache, &logAttr, &lineOffset))
		{
			ULONG nStart = cm.nOffset, nEnd = cm.nOffset;
			ULONG nLineEnd = m_pTextDoc->LineOffset(cm.nLine + 1), cch;

			while(nStart > lineOffset && !logAttr[nStart - lineOffset].fWordStop && !logAttr[nStart - lineOffset].fWhiteSpace)
				nStart--;
			while(nEnd < nLineEnd && !logAttr[nEnd - lineOffset].fWordStop && !logAttr[nEnd - lineOffset].fWhiteSpace)
				nEnd++;

			if(nStart < nEnd && logAttr[nStart - lineOffset].fWhiteSpace)
				nStart++;

			cch = nEnd - nStart;
			if(0 < cch)
			{
				cm.pcwzWord = __new WCHAR[cch + 1];
				if(cm.pcwzWord)
				{
					size_w cchCopied = 0;
					m_pTextDoc->Render(nStart, const_cast<PWSTR>(cm.pcwzWord), cch, &cchCopied);
					const_cast<PWSTR>(cm.pcwzWord)[cchCopied] = L'\0';

					cm.nWordOffset = nStart;
				}
			}
		}

		NotifyParent(TVN_INIT_CONTEXT_MENU, &cm);
		cc.pvUserParam = cm.pvUserParam;
		TrackPopupMenu(cm.hMenu, 0, x, y, 0, m_hwnd, NULL);
		NotifyParent(TVN_CLOSE_CONTEXT_MENU, &cc);
		DestroyMenu(cm.hMenu);

		if(cm.pcwzWord)
			__delete_array const_cast<PWSTR>(cm.pcwzWord);
	}
	return 0;
}

LRESULT CTextEditor::OnMouseWheel (int nDelta)
{
#ifndef	SPI_GETWHEELSCROLLLINES	
#define SPI_GETWHEELSCROLLLINES   104
#endif

	if(!IsKeyPressed(VK_SHIFT))
	{
		int nScrollLines;

		SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &nScrollLines, 0);

		if(nScrollLines <= 1)
			nScrollLines = 3;

		Scroll(0, (-nDelta/120) * nScrollLines);
		RepositionCaret();
	}

	return 0;
}

LRESULT CTextEditor::OnTimer (UINT_PTR nTimer)
{
	int	  dx = 0, dy = 0;	// scrolling vectors
	RECT  rect;
	POINT pt;
	
	// find client area, but make it an even no. of lines
	GetClientRect(m_hwnd, &rect);
	rect.bottom -= rect.bottom % m_nLineHeight;
	rect.left   += LeftMarginWidth();

	// get the mouse's client-coordinates
	GetCursorPos(&pt);
	ScreenToClient(m_hwnd, &pt);

	//
	// scrolling up / down??
	//
	if(pt.y < rect.top)
		dy = ScrollDir(m_nScrollCounter, pt.y - rect.top);

	else if(pt.y >= rect.bottom)	
		dy = ScrollDir(m_nScrollCounter, pt.y - rect.bottom);

	//
	// scrolling left / right?
	//
	if(pt.x < rect.left)					
		dx = ScrollDir(m_nScrollCounter, pt.x - rect.left);

	else if(pt.x > rect.right)		
		dx = ScrollDir(m_nScrollCounter, pt.x - rect.right);

	//
	// Scroll the window but don't update any invalid
	// areas - we will do this manually after we have 
	// repositioned the caret
	//
	HRGN hrgnUpdate = ScrollRgn(dx, dy, true);

	//
	// do the redraw now that the selection offsets are all 
	// pointing to the right places and the scroll positions are valid.
	//
	if(hrgnUpdate != NULL)
	{
		// We perform a "fake" WM_MOUSEMOVE for two reasons:
		//
		// 1. To get the cursor/caret/selection offsets set to the correct place
		//    *before* we redraw (so everything is synchronized correctly)
		//
		// 2. To invalidate any areas due to mouse-movement which won't
		//    get done until the next WM_MOUSEMOVE - and then it would
		//    be too late because we need to redraw *now*
		//
		OnMouseMove(0, pt.x, pt.y);

		// invalidate the area returned by ScrollRegion
		InvalidateRgn(m_hwnd, hrgnUpdate, FALSE);
		DeleteObject(hrgnUpdate);

		// the next time we process WM_PAINT everything 
		// should get drawn correctly!!
		UpdateWindow(m_hwnd);
	}

	// keep track of how many WM_TIMERs we process because
	// we might want to skip the next one
	m_nScrollCounter++;

	return 0;
}

LRESULT CTextEditor::OnLButtonDown (UINT nFlags, int mx, int my)
{
	ULONG nLineNo;
	ULONG nFileOff;
	INT xMargin = LeftMarginWidth();

	// regular mouse input - mouse is within 
	if(mx >= xMargin)
	{
		// map the mouse-coordinates to a real file-offset-coordinate
		MouseCoordToFilePos(mx, my, &nLineNo, &nFileOff, &m_nCaretPosX);
		m_nAnchorPosX = m_nCaretPosX;

		UpdateCaretXY(m_nCaretPosX, nLineNo);

		// Any key but <shift>
		if(IsKeyPressed(VK_SHIFT) == false)
		{
			// remove any existing selection
			InvalidateRange(m_nSelectionStart, m_nSelectionEnd);

			// reset cursor and selection offsets to the same location
			m_nSelectionStart	= nFileOff;
			m_nSelectionEnd		= nFileOff;
			m_nCursorOffset		= nFileOff;
		}
		else
		{
			// redraw to cursor
			InvalidateRange(m_nSelectionEnd, nFileOff);
			
			// extend selection to cursor
			m_nSelectionEnd		= nFileOff;
			m_nCursorOffset		= nFileOff;
		}

		if(IsKeyPressed(VK_MENU))
		{
			m_cpBlockStart.line = nLineNo;
			m_cpBlockStart.xpos = m_nCaretPosX;
			m_nSelectionType	= SEL_BLOCK;
		}
		else
		{
			m_nSelectionType	= SEL_NORMAL;
		}

		// set capture for mouse-move selections
		m_nSelectionMode = IsKeyPressed(VK_MENU) ? SEL_BLOCK : SEL_NORMAL;
	}
	// mouse clicked within margin 
	else
	{
		nLineNo = (my / m_nLineHeight) + m_nVScrollPos;

		// Only send the TVN_MARGIN_CLICK notification when TXS_LEFTMARGIN is enabled.
		if(CheckStyle(TXS_LEFTMARGIN) && mx < m_nLineHeight + 5)
		{
			TVNMARGINCLICK mc;
			mc.nLineNo = nLineNo;
			mc.fHandled = FALSE;
			NotifyParent(TVN_MARGIN_CLICK, &mc);

			// If the parent handled the click, then just return now.
			if(mc.fHandled)
				return 0;
		}

		// remove any existing selection
		InvalidateRange(m_nSelectionStart, m_nSelectionEnd);

		//
		// if we click in the margin then jump back to start of line
		//
		if(m_nHScrollPos != 0)
		{
			m_nHScrollPos = 0;
			SetupScrollbars();
			RefreshWindow();
		}

		m_nSelectionStart = m_pTextDoc->LineOffset(nLineNo);
		m_nSelectionEnd = m_nSelectionStart + m_pTextDoc->LineLength(nLineNo);
		m_nCursorOffset	    = m_nSelectionStart;

		m_nSelMarginOffset1 = m_nSelectionStart;
		m_nSelMarginOffset2 = m_nSelectionEnd;

		InvalidateRange(m_nSelectionStart, m_nSelectionEnd);

		UpdateCaretOffset(m_nCursorOffset, FALSE, &m_nCaretPosX, &nLineNo);
		m_nAnchorPosX = m_nCaretPosX;

		// set capture for mouse-move selections
		m_nSelectionMode = SEL_MARGIN;
	}

	UpdateLine(nLineNo);

	SetCapture(m_hwnd);

	TVNCURSORINFO ci;
	ci.nLineNo = nLineNo;
	ci.nColumnNo = GetCurrentColumn();
	ci.nOffset = m_nCursorOffset;
	NotifyParent(TVN_CURSOR_CHANGE, &ci);
	return 0;
}

LRESULT CTextEditor::OnLButtonUp (UINT nFlags, int x, int y)
{
	// shift cursor to end of selection
	if(m_nSelectionMode == SEL_MARGIN)
	{
		ULONG nLine;

		m_nCursorOffset = m_nSelectionEnd;
		UpdateCaretOffset(m_nCursorOffset, FALSE, &m_nCaretPosX, &nLine);
		UpdateLine(nLine);
	}

	if(m_nSelectionMode)
	{
		// cancel the scroll-timer if it is still running
		if(m_nScrollTimer != 0)
		{
			UnregisterTimer(m_nScrollTimer);
			m_nScrollTimer = 0;
		}

		m_nSelectionMode = SEL_NONE;
		ReleaseCapture();
	}

	return 0;
}

LRESULT CTextEditor::OnLButtonDblClick (UINT nFlags, int mx, int my)
{
	// remove any existing selection
	InvalidateRange(m_nSelectionStart, m_nSelectionEnd);

	// regular mouse input - mouse is within scrolling viewport
	if(mx >= LeftMarginWidth())
	{
		ULONG lineno, fileoff;
		int   xpos;

		// map the mouse-coordinates to a real file-offset-coordinate
		MouseCoordToFilePos(mx, my, &lineno, &fileoff, &xpos);
		m_nAnchorPosX = m_nCaretPosX;

		// move selection-start to start of word
		MoveWordStart();
		m_nSelectionStart = m_nCursorOffset;

		// move selection-end to end of word
		MoveWordEnd();
		m_nSelectionEnd = m_nCursorOffset;

		// update caret position
		InvalidateRange(m_nSelectionStart, m_nSelectionEnd);
		UpdateCaretOffset(m_nCursorOffset, TRUE, &m_nCaretPosX, &m_nCurrentLine);
		m_nAnchorPosX = m_nCaretPosX;

		TVNCURSORINFO ci;
		ci.nLineNo = m_nCurrentLine;
		ci.nColumnNo = GetCurrentColumn();
		ci.nOffset = m_nCursorOffset;
		NotifyParent(TVN_CURSOR_CHANGE, &ci);
	}

	return 0;
}

LRESULT CTextEditor::OnMouseMove (UINT nFlags, int mx, int my)
{
	if(m_nSelectionMode)
	{
		ULONG	nLineNo, nFileOff;
		BOOL	fCurChanged = FALSE;

		RECT	rect;
		POINT	pt = { mx, my };

		//
		//	First thing we must do is switch from margin-mode to normal-mode 
		//	if the mouse strays into the main document area
		//
		if(m_nSelectionMode == SEL_MARGIN && mx > LeftMarginWidth())
		{
			m_nSelectionMode = SEL_NORMAL;
			SetCursor(LoadCursor(0, IDC_IBEAM));
		}

		//
		//	Mouse-scrolling: detect if the mouse
		//	is inside/outside of the TextView scrolling area
		//  and stop/start a scrolling timer appropriately
		//
		GetClientRect(m_hwnd, &rect);
		
		// build the scrolling area
		rect.bottom -= rect.bottom % m_nLineHeight;
		rect.left   += LeftMarginWidth();

		// If mouse is within this area, we don't need to scroll
		if(PtInRect(&rect, pt))
		{
			if(m_nScrollTimer != 0)
			{
				UnregisterTimer(m_nScrollTimer);
				m_nScrollTimer = 0;
			}
		}
		// If mouse is outside window, start a timer in
		// order to generate regular scrolling intervals
		else 
		{
			if(m_nScrollTimer == 0)
			{
				m_nScrollCounter = 0;
				RegisterTimer(30, &m_nScrollTimer);
			}
		}

		// get new cursor offset+coordinates
		MouseCoordToFilePos(mx, my, &nLineNo, &nFileOff, &m_nCaretPosX);
		m_nAnchorPosX = m_nCaretPosX;

		m_cpBlockEnd.line = nLineNo;
		m_cpBlockEnd.xpos = mx + m_nHScrollPos * m_nFontWidth - LeftMarginWidth();//m_nCaretPosX;

		// redraw the old and new lines if they are different
		UpdateLine(nLineNo);

		// update the region of text that has changed selection state
		fCurChanged = m_nSelectionEnd == nFileOff ? FALSE : TRUE;
		//if(m_nSelectionEnd != nFileOff)
		{
			ULONG linelen = m_pTextDoc->LineLength(nLineNo);

			m_nCursorOffset	= nFileOff;

			if(m_nSelectionMode == SEL_MARGIN)
			{
				if(nFileOff >= m_nSelectionStart)
				{
					nFileOff += linelen;
					m_nSelectionStart = m_nSelMarginOffset1;
				}
				else
				{
					m_nSelectionStart = m_nSelMarginOffset2;
				}
			}

			// redraw from old selection-pos to new position
			InvalidateRange(m_nSelectionEnd, nFileOff);

			// adjust the cursor + selection to the new offset
			m_nSelectionEnd = nFileOff;
		}

		if(m_nSelectionMode == SEL_BLOCK)
			RefreshWindow();

		// m_nCaretPosX = mx+m_nHScrollPos*m_nFontWidth-LeftMarginWidth();
		// always set the caret position because we might be scrolling
		UpdateCaretXY(m_nCaretPosX, m_nCurrentLine);

		if(fCurChanged)
		{
			TVNCURSORINFO ci;
			ci.nLineNo = m_nCurrentLine;
			ci.nColumnNo = GetCurrentColumn();
			ci.nOffset = m_nCursorOffset;
			NotifyParent(TVN_CURSOR_CHANGE, &ci);
		}
	}
	// mouse isn't being used for a selection, so set the cursor instead
	else
	{
		if(mx < LeftMarginWidth())
		{
			SetCursor(m_hMarginCursor);
		}
		else
		{
			//OnLButtonDown(0, mx, my);
			SetCursor(LoadCursor(0, IDC_IBEAM));
		}
	}

	return 0;
}

LRESULT CTextEditor::OnKeyDown (UINT nKeyCode, UINT nFlags)
{
	bool fCtrlDown	= IsKeyPressed(VK_CONTROL);
	bool fShiftDown	= IsKeyPressed(VK_SHIFT);
	BOOL fAdvancing = FALSE;

	switch(nKeyCode)
	{
	case VK_SHIFT:
	case VK_CONTROL:
		return 0;

	// CTRL+Z undo
	case L'Z':
		return fCtrlDown && Undo();

	// CTRL+Y redo
	case L'Y':
		return fCtrlDown && Redo();

	case L'A':
		return fCtrlDown && SelectAll();

	case L'C':
		return fCtrlDown && OnCopy();

	case L'V':
		return fCtrlDown && OnPaste();

	case L'X':
		return fCtrlDown && OnCut();

	// Change insert mode / clipboard copy&paste
	case VK_INSERT:
		if(fCtrlDown)
			OnCopy();
		else if(fShiftDown)
			OnPaste();
		else
		{
			if(m_nEditMode == MODE_INSERT)
				m_nEditMode = MODE_OVERWRITE;
			else if(m_nEditMode == MODE_OVERWRITE)
				m_nEditMode = MODE_INSERT;

			NotifyParent(TVN_EDITMODE_CHANGE);
		}
		return 0;

	case VK_DELETE:
		if(m_nEditMode != MODE_READONLY)
		{
			if(fShiftDown)
				OnCut();
			else
				ForwardDelete();
		}
		return 0;

	case VK_BACK:
		if(m_nEditMode != MODE_READONLY)
		{
			BackDelete();
			fAdvancing = FALSE;
		}
		return 0;

	case VK_LEFT:
		if(fCtrlDown)	MoveWordPrev();
		else			MoveCharPrev();

		fAdvancing = FALSE;
		break;

	case VK_RIGHT:
		if(fCtrlDown)	MoveWordNext();
		else			MoveCharNext();
			
		fAdvancing = TRUE;
		break;

	case VK_UP:
		if(fCtrlDown)	Scroll(0, -1);
		else			MoveLineUp(1);
		break;

	case VK_DOWN:
		if(fCtrlDown)	Scroll(0, 1);
		else			MoveLineDown(1);
		break;

	case VK_PRIOR:
		if(!fCtrlDown)	MoveLineUp(m_nWindowLines);
		break;

	case VK_NEXT:
		if(!fCtrlDown)	MoveLineDown(m_nWindowLines);
		break;

	case VK_HOME:
		if(fCtrlDown)	MoveFileStart();
		else			MoveLineStart(m_nCurrentLine);
		break;

	case VK_END:
		if(fCtrlDown)	MoveFileEnd();
		else			MoveLineEnd(m_nCurrentLine);
		break;

	default:
		return 0;
	}

	FinalizeNavigation(nKeyCode, fShiftDown, fCtrlDown, fAdvancing);

	return 0;
}

LRESULT CTextEditor::OnChar (UINT nChar, UINT nFlags)
{
	if(nChar >= L' ' || nChar == L'\t' || nChar == L'\r')
	{
		WCHAR wch = (WCHAR)nChar;
		if(EnterText(&wch, 1))
		{
			// change CR into a CR/LF sequence
			if(nChar == L'\r')
			{
				WCHAR wch = L'\n';
				if(EnterText(&wch, 1))
					m_pTextDoc->Break();
			}

			SendUpdateCommand();
		}
	}

	return 0;
}

LRESULT CTextEditor::OnPaint (VOID)
{
	PAINTSTRUCT ps;
	ULONG		first;
	ULONG		last;
	
	HRGN		hrgnUpdate;
	HDC			hdcMem;
	HBITMAP		hbmMem;
	RECT		rect;

	//
	// get update region *before* BeginPaint validates the window
	//
	hrgnUpdate = CreateRectRgn(0,0,1,1);
	GetUpdateRgn(m_hwnd, hrgnUpdate, FALSE);

	//
	// create a memoryDC the same size a single line, for double-buffering
	//
	BeginPaint(m_hwnd, &ps);
	GetClientRect(m_hwnd, &rect);

	hdcMem = CreateCompatibleDC(ps.hdc);
	hbmMem = CreateCompatibleBitmap(ps.hdc, rect.right-rect.left, m_nLineHeight);

	SelectObject(hdcMem, hbmMem);

	//
	// figure out which lines to redraw
	//
	first = m_nVScrollPos + ps.rcPaint.top    / m_nLineHeight;
	last  = m_nVScrollPos + ps.rcPaint.bottom / m_nLineHeight;

	// make sure we never wrap around the 4gb boundary
	if(last < first) 
		last = -1;

	//
	// draw the display line-by-line
	//
	for(ULONG i = first; i <= last; i++)
	{
		int sx		= 0;
		int sy		= (i - m_nVScrollPos) * m_nLineHeight;
		int width	= rect.right - rect.left;

		// prep the background
		PaintRect(hdcMem, 0, 0, width, m_nLineHeight, LineColor(i));

		// draw each line into the offscreen buffer
		PaintLine(hdcMem, i, -m_nHScrollPos * m_nFontWidth, 0, hrgnUpdate);

		// transfer to screen 
		BitBlt(	ps.hdc, sx, sy, width, m_nLineHeight, hdcMem, 0, 0, SRCCOPY);
	}

	//
	//	Cleanup
	//
	EndPaint(m_hwnd, &ps);

	DeleteDC(hdcMem);
	DeleteObject(hbmMem);
	DeleteObject(hrgnUpdate);

	return 0;
}

LRESULT CTextEditor::OnSetFont (HFONT hFont)
{
	// default font is always #0
	SetFont(hFont, 0);
	UpdateMetrics();

	return 0;
}

LRESULT CTextEditor::OnSetFocus (HWND hwndOld)
{
	if(!m_fHideCaret)
	{
		CreateCaret(m_hwnd, (HBITMAP)NULL, m_nCaretWidth, m_nLineHeight);
		RepositionCaret();

		ShowCaret(m_hwnd);
		RefreshWindow();
	}

	return 0;
}

LRESULT CTextEditor::OnKillFocus (HWND hwndNew)
{
	// if we are making a selection when we lost focus then
	// stop the selection logic
	if(m_nSelectionMode != SEL_NONE)
	{
		OnLButtonUp(0, 0, 0);
	}

	HideCaret(m_hwnd);
	DestroyCaret();
	RefreshWindow();
	return 0;
}

BOOL CTextEditor::OnCut ()
{
	BOOL fSuccess = FALSE;

	if(m_nEditMode != MODE_READONLY)
	{
		if(SelectionSize() > 0)
		{
			// copy selected text to clipboard then erase current selection
			fSuccess = OnCopy() && ForwardDelete();
		}
	}

	return fSuccess;
}

BOOL CTextEditor::OnCopy ()
{
	BOOL	fSuccess	= FALSE;
	ULONG	sellen		= SelectionSize();

	if(sellen != 0)
	{
		ULONG	selstart	= min(m_nSelectionStart, m_nSelectionEnd);
		if(OpenClipboard(m_hwnd))
		{
			HANDLE hMem;
			WCHAR  *ptr;

			if((hMem = GlobalAlloc(GPTR, (sellen + 1) * sizeof(WCHAR))) != NULL)
			{
				if((ptr = (WCHAR *)GlobalLock(hMem)) != 0)
				{
					EmptyClipboard();

					GetText(ptr, selstart, sellen + 1);
					GlobalUnlock(hMem);

					SetClipboardData(CF_UNICODETEXT, hMem);
					fSuccess = TRUE;
				}
			}

			CloseClipboard();
		}
	}

	return fSuccess;
}

BOOL CTextEditor::OnPaste ()
{
	BOOL fSuccess = FALSE;

	if(m_nEditMode != MODE_READONLY)
	{
		if(OpenClipboard(m_hwnd))
		{
			HANDLE hMem		= GetClipboardData(CF_UNICODETEXT);
			ULONG cchText	= GlobalSize(hMem) / sizeof(WCHAR);
			PCWSTR pcwzText	= (PCWSTR)GlobalLock(hMem);

			if(pcwzText)
			{
				if(0 < cchText && L'\0' == pcwzText[cchText - 1])
					cchText--;

				EnterText(pcwzText, cchText);

				if(1 < cchText)
					m_pTextDoc->Break();

				GlobalUnlock(hMem);
				SendUpdateCommand();

				fSuccess = TRUE;
			}

			CloseClipboard();
		}
	}

	return fSuccess;
}

BOOL CTextEditor::OnClear ()
{
	BOOL fSuccess = FALSE;

	if(m_nEditMode != MODE_READONLY)
	{
		if(SelectionSize() > 0)
		{
			ForwardDelete();
			fSuccess = TRUE;
		}
	}

	return fSuccess;
}
